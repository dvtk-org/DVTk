name: .NET Desktop Build (VS2019)

on:
  push:
    branches:
      - '*'
  pull_request:
    branches:
      - '*'

env:
  SOLUTION: 'Dicom.sln'
  BUILD_PLATFORM: 'x86'
  BUILD_CONFIGURATION: 'Release'

jobs:
  build:
    runs-on: windows-2019

    steps:
    - name: Checkout source code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install GitVersion
      uses: gittools/actions/gitversion/setup@v3.0.0
      with:
        versionSpec: '5.x'
        preferLatestVersion: true

    - name: Determine version number using GitVersion
      id: gitversion
      uses: gittools/actions/gitversion/execute@v3.0.0
      with:
        useConfigFile: true
        configFilePath: 'GitVersion.yml'
        updateAssemblyInfo: true

    - name: Setup NuGet
      uses: NuGet/setup-nuget@v2
      with:
        nuget-config-file: 'NuGet.config'

    - name: Restore Nuget packages
      run: nuget restore ${{ env.SOLUTION }} -Verbosity Detailed

    - name: Update Version in project files
      shell: pwsh
      run: |
        ./DVT/updateVersion.ps1 -gitversion "${{ env.GITVERSION_FULLSEMVER }}"

    - name: Update Copyright year in AssemblyInfo files
      shell: pwsh
      run: |
        ./DVT/updateCopyright.ps1

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Locate Devenv and Manual Registry Fix
      shell: pwsh
      run: |
        # Zoek VS2019 gegevens via vswhere
        $vsPath = & "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -version "[16.0,17.0)" -property installationPath
        $instanceId = & "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -version "[16.0,17.0)" -property instanceId
        
        if (-not $vsPath) { throw "Visual Studio 2019 niet gevonden!" }
        
        # Voer Registry Fix uit voor HRESULT 8000000A 
        $registryPath = "HKCU:\SOFTWARE\Microsoft\VisualStudio\16.0_$($instanceId)_Config\MSBuild"
        if (!(Test-Path $registryPath)) {
            New-Item -Path $registryPath -Force | Out-Null
        }
        Set-ItemProperty -Path $registryPath -Name "EnableOutOfProcBuild" -Value 0 -Type DWord
        Write-Host "Registry fix toegepast op $registryPath"

        # Sla pad op voor volgende stappen
        $devenv = Join-Path $vsPath "Common7\IDE\devenv.com"
        Add-Content -Path $env:GITHUB_ENV -Value "DEV_CMD=$devenv"

    - name: Setup Visual Studio Installer Projects
      uses: seanmiddleditch/gha-setup-vsdevenv@v5

    - name: Build managed/native projects (msbuild)
      id: msbuild
      shell: pwsh
      run: |
        New-Item -ItemType Directory -Force -Path ./staging
        & msbuild Dicom.sln /t:Rebuild '/p:Configuration=Release;Platform=x86' /m /fl /flp:LogFile=./staging/build-msbuild.log

    - name: Build setup projects (devenv)
      id: vdproj
      continue-on-error: true
      shell: pwsh
      run: |
        $projects = @(
            "DVT Setup",
            "DICOM Editor Setup",
            "DICOM Compare Setup",
            "DICOM Network Analyzer Setup",
            "Query Retrieve SCP Emulator Setup",
            "Query Retrieve SCU Emulator Setup",
            "RIS Emulator Setup",
            "Storage SCP Emulator Setup",
            "Storage SCU Emulator Setup"
        )
        
        if (-not (Test-Path "$env:DEV_CMD")) { throw "Fout: DEV_CMD (devenv.com) niet gevonden op het systeem." }
        
        $logPath = "./staging/build-devenv.log"
        if (Test-Path $logPath) { Remove-Item $logPath -Force }
        
        $anyFailure = $false
        
        foreach ($p in $projects) {
            Write-Host "--- Bouwen van: $p ---"
            
            # Gebruik de ingebouwde /Out vlag van devenv voor maximale snelheid en stabiliteit
            # Devenv schrijft dan direct naar een tijdelijk bestand.
            $tempLog = "temp_$($p.Replace(' ', '_')).log"
            
            $process = Start-Process -FilePath "$env:DEV_CMD" `
                -ArgumentList "`"$env:SOLUTION`"", "/Build", "`"$env:BUILD_CONFIGURATION|$env:BUILD_PLATFORM`"", "/Project", "`"$p`"", "/Out", "$tempLog" `
                -Wait -PassThru
                
            # Combineer de logs achteraf (veel sneller dan regel voor regel tijdens de build)
            if (Test-Path $tempLog) {
                $content = Get-Content $tempLog
                $content | Out-File -FilePath $logPath -Append -Encoding UTF8
                $content | Write-Host  # Toon de output ook in de GitHub console
                Remove-Item $tempLog
            }
            
            if ($process.ExitCode -ne 0) {
                Write-Error "Fout tijdens bouwen van $p (Exit code: $($process.ExitCode))"
                $anyFailure = $true
            }
        }
        
        if ($anyFailure) { exit 1 }

    - name: Show last lines of build log (only if build failed)
      if: ${{ steps.vdproj.outcome == 'failure' }}
      shell: pwsh
      run: |
        if (Test-Path build-devenv.log) {
          Write-Host "=== Last 200 lines of build-devenv.log ==="
          Get-Content build-devenv.log -Tail 200
        }

    - name: Run Tests
      if: ${{ always() }}
      shell: cmd
      run: |
        vstest.console.exe ".\bin\Release\*Tests.dll"

    - name: Rename MSI files with version number
      if: ${{ always() }}
      shell: pwsh
      run: |
        $searchPath = "bin\Setups\Release"
        $version = "${{ env.GITVERSION_FULLSEMVER }}"
        
        Write-Host "Zoeken naar MSI bestanden in: $searchPath"
        
        # Zoek alle MSI bestanden die de placeholder '-a.b.c' bevatten
        $msiFiles = Get-ChildItem -Path $searchPath -Filter "*-a.b.c.msi" -Recurse
        
        if ($msiFiles.Count -eq 0) {
            Write-Warning "Geen MSI bestanden gevonden met de placeholder '-a.b.c.msi'. Mogelijk is de build mislukt of zijn ze al hernoemd."
        }
        
        foreach ($file in $msiFiles) {
            $newName = $file.Name.Replace("-a.b.c", "-$version")
            $destination = Join-Path "./staging" $newName
            
            Write-Host "Hernoemen: $($file.Name) -> $newName"
            
            # Controleer of het doelbestand al bestaat om fouten te voorkomen
            if (Test-Path $destination) {
                Write-Host "Bestand $newName bestaat al, verwijderen van oud bestand..."
                Remove-Item $destination -Force
            }
            
            Move-Item -Path $file.FullName -Destination $destination -Force
        }
        Get-ChildItem -Path "./staging" -Filter "*.msi" -Recurse | Select-Object FullName

    - name: Publish build artifacts
      if: ${{ always() }}
      uses: actions/upload-artifact@v4
      with:
        name: "${{ github.event.repository.name }}-Package-${{ env.GITVERSION_FULLSEMVER }}"
        path: ./staging