name: DVTk Build (VS2022)

on:
  push:
    branches:
      - '*'
  pull_request:
    branches:
      - '*'
  workflow_dispatch:

env:
  SOLUTION: 'Dicom.sln'
  BUILD_PLATFORM: 'x86'
  BUILD_CONFIGURATION: 'Release'

jobs:
  build:
    runs-on: windows-2022

    steps:
    - name: Checkout source code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install GitVersion
      uses: gittools/actions/gitversion/setup@v3.0.0
      with:
        versionSpec: '5.x'
        preferLatestVersion: true

    - name: Determine version number using GitVersion
      id: gitversion
      uses: gittools/actions/gitversion/execute@v3.0.0
      with:
        useConfigFile: true
        configFilePath: 'GitVersion.yml'
        updateAssemblyInfo: true

    - name: Setup NuGet
      uses: NuGet/setup-nuget@v2

    - name: Restore Nuget packages
      run: nuget restore ${{ env.SOLUTION }} -Verbosity Detailed

    - name: Update Version in project files
      shell: pwsh
      run: |
        ./DVT/updateVersion.ps1 -gitversion "${{ steps.gitversion.outputs.majorMinorPatch }}"

    - name: Update Copyright year in AssemblyInfo files
      shell: pwsh
      run: |
        ./DVT/updateCopyright.ps1

    - name: Install MFC and ATL (v142 compatibility)
      shell: cmd
      run: |
        "C:\Program Files (x86)\Microsoft Visual Studio\Installer\setup.exe" modify ^
        --installPath "C:\Program Files\Microsoft Visual Studio\2022\Enterprise" ^
        --add Microsoft.VisualStudio.Component.VC.14.29.16.11.ATL ^
        --add Microsoft.VisualStudio.Component.VC.14.29.16.11.MFC ^
        --quiet --norestart

    - name: Verify MFC Headers
      shell: pwsh
      run: |
        $header = Get-ChildItem -Path "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC" -Recurse -Filter "afx.h" -ErrorAction SilentlyContinue
        if ($header) {
            Write-Host "‚úÖ afx.h gevonden in: $($header.FullName)"
        } else {
            Write-Error "‚ùå afx.h nog steeds niet gevonden op de schijf."
            exit 1
        }

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2
      with:
        vs-version: '[17.0,18.0)'

    - name: Verify MFC Installation
      shell: pwsh
      run: |
        # Gebruik -requires om direct te filteren op de component, dit is betrouwbaarder dan handmatig de lijst doorzoeken
        $mfcCheck = & "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -latest -requires Microsoft.VisualStudio.Component.VC.MFC -property installationPath
        
        if ($mfcCheck) {
            Write-Host "‚úÖ MFC Component is succesvol gedetecteerd in: $mfcCheck"
        } else {
            Write-Host "‚ö†Ô∏è Waarschuwing: vswhere herkent de component nog niet. We checken nu het bestandssysteem..."
            
            # Fallback: Controleer of de MFC mappen daadwerkelijk bestaan op schijf
            $vsPath = & "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -latest -property installationPath
            $mfcHeader = Get-ChildItem -Path "$vsPath\VC\Tools\MSVC" -Recurse -Filter "afxwin.h" -ErrorAction SilentlyContinue
            
            if ($mfcHeader) {
                Write-Host "‚úÖ MFC bestanden gevonden op schijf: $($mfcHeader.FullName)"
            } else {
                Write-Error "‚ùå MFC Component NIET gevonden (niet via vswhere en niet op het bestandssysteem)."
                exit 1
            }
        }

    - name: Locate Devenv and Manual Registry Fix
      shell: pwsh
      run: |
        # Search VS2022 via vswhere
        $vsPath = & "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -version "[17.0,18.0)" -property installationPath
        $instanceId = & "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -version "[17.0,18.0)" -property instanceId
        
        if (-not $vsPath) { throw "Visual Studio 2022 not found!" }
        
        # Execute Registry Fix for HRESULT 8000000A 
        $registryPath = "HKCU:\SOFTWARE\Microsoft\VisualStudio\17.0_$($instanceId)_Config\MSBuild"
        if (!(Test-Path $registryPath)) {
            New-Item -Path $registryPath -Force | Out-Null
        }
        Set-ItemProperty -Path $registryPath -Name "EnableOutOfProcBuild" -Value 0 -Type DWord
        Write-Host "Registry fix applied to $registryPath"

        $devenv = Join-Path $vsPath "Common7\IDE\devenv.com"
        Add-Content -Path $env:GITHUB_ENV -Value "DEV_CMD=$devenv"

    - name: Setup Visual Studio Installer Projects
      uses: seanmiddleditch/gha-setup-vsdevenv@v5

    - name: Build managed/native projects (msbuild)
      id: msbuild
      shell: pwsh
      run: |
        New-Item -ItemType Directory -Force -Path ./staging
        # Importeer de VS Developer Environment voor x86
        & cmd /c "call `"C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat`" x86 -vcvars_ver=14.2 && msbuild Dicom.sln /t:Rebuild /p:Configuration=Release /p:Platform=x86 /m /fl /flp:LogFile=./staging/build-msbuild.log"

    - name: Build setup projects (devenv)
      id: vdproj
      continue-on-error: true
      shell: pwsh
      run: |
        $projects = @(
            #"Definition Files Setup",
            "DICOM Compare Setup",
            "DICOM Editor Setup",
            "DICOM Network Analyzer Setup",
            "DVT Examples Setup",
            "DVT Setup",
            #"Modality Emulator Setup",
            "Query Retrieve SCP Emulator Setup",
            "Query Retrieve SCU Emulator Setup",
            "RIS Emulator Setup",
            "Storage SCP Emulator Setup",
            "Storage SCU Emulator Setup"
        )
        
        if (-not (Test-Path "$env:DEV_CMD")) { throw "Error: DEV_CMD (devenv.com) not found on the system." }
        
        $logPath = "./staging/build-devenv.log"
        if (Test-Path $logPath) { Remove-Item $logPath -Force }
        
        $anyFailure = $false
        
        foreach ($p in $projects) {
            Write-Host "--- Building: $p ---"
            
            $tempLog = "temp_$($p.Replace(' ', '_')).log"
            
            $process = Start-Process -FilePath "$env:DEV_CMD" `
                -ArgumentList "`"$env:SOLUTION`"", "/Build", "`"$env:BUILD_CONFIGURATION|$env:BUILD_PLATFORM`"", "/Project", "`"$p`"", "/Out", "$tempLog" `
                -Wait -PassThru
                
            if (Test-Path $tempLog) {
                $content = Get-Content $tempLog
                $content | Out-File -FilePath $logPath -Append -Encoding UTF8
                $content | Write-Host  # Toon de output ook in de GitHub console
                Remove-Item $tempLog
            }
            
            if ($process.ExitCode -ne 0) {
                Write-Error "Error during build of $p (Exit code: $($process.ExitCode))"
                $anyFailure = $true
            }
        }
        
        if ($anyFailure) { exit 1 }

    - name: Run Tests
      continue-on-error: true
      shell: cmd
      run: |
        vstest.console.exe ".\bin\Release\*Tests.dll" --logger:trx;LogFileName=../staging/test-results.trx

    - name: Upload Test Results Artifact
      uses: actions/upload-artifact@v4
      with:
        name: test-results-trx
        path: staging/*.trx

    - name: Rename MSI files with version number
      shell: pwsh
      run: |
        $searchPath = "bin\Setups\Release"
        $version = "${{ steps.gitversion.outputs.majorMinorPatch }}"
        
        Write-Host "Search all MSI files in: $searchPath"
        $msiFiles = Get-ChildItem -Path $searchPath -Filter "*-a.b.c.msi" -Recurse
        
        if ($msiFiles.Count -eq 0) {
            Write-Warning "No MSI files found with placeholder '-a.b.c.msi'."
        }
        
        foreach ($file in $msiFiles) {
            $newName = $file.Name.Replace("-a.b.c", "-$version")
            $destination = Join-Path "./staging" $newName
            
            Write-Host "Rename: $($file.Name) -> $newName"
            
            # Controleer of het doelbestand al bestaat om fouten te voorkomen
            if (Test-Path $destination) {
                Write-Host "Bestand $newName bestaat al, verwijderen van oud bestand..."
                Remove-Item $destination -Force
            }
            
            Move-Item -Path $file.FullName -Destination $destination -Force
        }
        Get-ChildItem -Path "./staging" -Filter "*.msi" -Recurse | Select-Object FullName

    - name: Sign MSI files
      if: ${{ github.event_name != 'pull_request' }}
      shell: pwsh
      run: |
        # Check of de secrets beschikbaar zijn
        if ([string]::IsNullOrEmpty("${{ secrets.CERTIFICATE_BASE64 }}")) {
            Write-Warning "‚ö†Ô∏è CERTIFICATE_BASE64 secret niet gevonden. MSI signing wordt overgeslagen."
            exit 0
        }
        
        if ([string]::IsNullOrEmpty("${{ secrets.CERTIFICATE_PASSWORD }}")) {
            Write-Warning "‚ö†Ô∏è CERTIFICATE_PASSWORD secret niet gevonden. MSI signing wordt overgeslagen."
            exit 0
        }
        
        Write-Host "üìú Decoding certificaat..."
        
        # Decode het base64 certificaat naar een bestand
        $certPath = Join-Path $env:TEMP "signing-cert.pfx"
        $certPassword = "${{ secrets.CERTIFICATE_PASSWORD }}"
        $securePassword = ConvertTo-SecureString -String $certPassword -AsPlainText -Force
        
        try {
            $certBytes = [Convert]::FromBase64String("${{ secrets.CERTIFICATE_BASE64 }}")
            [IO.File]::WriteAllBytes($certPath, $certBytes)
            Write-Host "‚úÖ Certificaat bestand aangemaakt: $certPath"
        } catch {
            Write-Error "‚ùå Fout bij decoden van certificaat: $_"
            exit 1
        }
        
        # Verificeer dat het bestand bestaat en leesbaar is
        if (-not (Test-Path $certPath)) {
            Write-Error "‚ùå Certificaat bestand niet gevonden na decode!"
            exit 1
        }
        
        $fileSize = (Get-Item $certPath).Length
        Write-Host "Certificaat bestand grootte: $fileSize bytes"
        
        # Importeer het certificaat in de certificate store
        Write-Host "üì• Importeren certificaat in certificate store..."
        try {
            $cert = Import-PfxCertificate -FilePath $certPath -CertStoreLocation Cert:\CurrentUser\My -Password $securePassword -ErrorAction Stop
            Write-Host "‚úÖ Certificaat ge√Ømporteerd met thumbprint: $($cert.Thumbprint)"
            Write-Host "   Subject: $($cert.Subject)"
            Write-Host "   Valid from: $($cert.NotBefore) to $($cert.NotAfter)"
            Write-Host "   Has private key: $($cert.HasPrivateKey)"
            
            if (-not $cert.HasPrivateKey) {
                Write-Error "‚ùå Certificaat heeft geen private key!"
                exit 1
            }
            
            $certThumbprint = $cert.Thumbprint
            
            # Controleer Enhanced Key Usage
            $eku = $cert.EnhancedKeyUsageList | Select-Object -ExpandProperty FriendlyName
            Write-Host "   Enhanced Key Usage: $($eku -join ', ')"
            
            if ($eku -notcontains "Code Signing") {
                Write-Warning "‚ö†Ô∏è Certificaat heeft geen 'Code Signing' capability. Signing kan falen."
            }
        } catch {
            Write-Error "‚ùå Fout bij importeren certificaat: $_"
            Write-Error "   Controleer of het wachtwoord correct is!"
            Remove-Item $certPath -Force -ErrorAction SilentlyContinue
            exit 1
        }
        
        # Verificeer dat certificaat zichtbaar is in store
        $storeCheck = Get-ChildItem Cert:\CurrentUser\My | Where-Object { $_.Thumbprint -eq $certThumbprint }
        if ($storeCheck) {
            Write-Host "‚úì Certificaat is zichtbaar in certificate store"
        } else {
            Write-Error "‚ùå Certificaat niet gevonden in store na import!"
            exit 1
        }
        
        # Vind signtool.exe - gebruik ALTIJD x64 versie voor betere store toegang
        $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Recurse -Filter "signtool.exe" -ErrorAction SilentlyContinue | 
                    Where-Object { $_.FullName -match '\\x64\\' } |
                    Sort-Object FullName -Descending | 
                    Select-Object -First 1
        
        if (-not $signtool) {
            Write-Error "‚ùå signtool.exe niet gevonden!"
            Remove-Item $certPath -Force -ErrorAction SilentlyContinue
            exit 1
        }
        
        Write-Host "üîß Using signtool: $($signtool.FullName)"
        
        # Sign alle MSI bestanden in staging
        $msiFiles = Get-ChildItem -Path "./staging" -Filter "*.msi" -Recurse
        
        if ($msiFiles.Count -eq 0) {
            Write-Warning "‚ö†Ô∏è Geen MSI bestanden gevonden om te signen."
            Remove-Item $certPath -Force -ErrorAction SilentlyContinue
            exit 0
        }
        
        Write-Host "Found $($msiFiles.Count) MSI file(s) to sign"
        
        $signedCount = 0
        $failedCount = 0
        
        foreach ($msi in $msiFiles) {
            Write-Host "`nüìù Signing: $($msi.Name)"
            
            # Sign met certificaat thumbprint uit de store + subject name als fallback
            & $signtool.FullName sign /sha1 $certThumbprint /n "Bennert.de.Wijs" /tr http://timestamp.digicert.com /td sha256 /fd sha256 /v /debug $msi.FullName
            
            if ($LASTEXITCODE -eq 0) {
                Write-Host "‚úÖ Successfully signed: $($msi.Name)"
                $signedCount++
                
                # Verify signature - gebruik /a in plaats van /pa voor self-signed certificaten
                $verifyOutput = & $signtool.FullName verify /a $msi.FullName 2>&1
                $verifyExitCode = $LASTEXITCODE
                
                if ($verifyExitCode -eq 0) {
                    Write-Host "   ‚úì Signature verified (trusted)"
                } else {
                    # Voor self-signed certificaten is dit normaal
                    if ($verifyOutput -match "root certificate which is not trusted") {
                        Write-Host "   ‚ö† Self-signed certificate (expected for test certificates)"
                    } else {
                        Write-Host "   ‚ö† Signature verification warning"
                    }
                }
                
                # Reset exit code na verify zodat het script niet faalt
                $LASTEXITCODE = 0
            } else {
                Write-Warning "‚ùå Failed to sign $($msi.Name) (Exit code: $LASTEXITCODE)"
                $failedCount++
            }
        }
        
        # Verwijder het certificaat uit de store en het bestand
        Write-Host "`nüóëÔ∏è Cleaning up..."
        try {
            Remove-Item "Cert:\CurrentUser\My\$certThumbprint" -Force -ErrorAction SilentlyContinue
            Write-Host "   Certificaat verwijderd uit store"
        } catch {
            Write-Warning "   Kon certificaat niet verwijderen uit store: $_"
        }
        Remove-Item $certPath -Force -ErrorAction SilentlyContinue
        Write-Host "   Certificate file removed"
        
        Write-Host "`nüìä Summary: $signedCount signed, $failedCount failed"
        
        if ($failedCount -gt 0) {
            Write-Error "‚ùå Some files failed to sign. Check if certificate and password are correct."
            exit 1
        }

    - name: Publish build artifacts
      if: ${{ always() }}
      uses: actions/upload-artifact@v4
      with:
        name: "${{ github.event.repository.name }}-Package-${{ steps.gitversion.outputs.majorMinorPatch }}.${{ steps.gitversion.outputs.preReleaseNumber }}.vs2022"
        path: ./staging

  publish-test-results:
    runs-on: ubuntu-latest
    needs: build
    if: always()
    permissions:
      checks: write
      pull-requests: write
      contents: read
    steps:
      - name: Download Test Results
        uses: actions/download-artifact@v4
        with:
          name: test-results-trx
          path: test-results

      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action@v2
        with:
          files: "test-results/**/*.trx"